---
title: Serial port locking
author: Sam Coleman
---

* TOC
{:toc}

https://gavv.github.io/articles/file-locks/

## Types of locks

* BSD locks (`flock(2)`)
* POSIX record locks (`fcntl(2)`)
* Simplified POSIX record locks (`lockf(3)`)
* Open file description locks (`fcntl(2)`)

## macOS

macOS seems to alias between BSD and both types of POSIX locks.
Acquiring an exclusive lock of one type will block the acquisition
of either of the other two types of locks.

### GNU Screen

Screen sets a lock on ports when opening them.
(Impossible to tell which of flock/fcntl/lockf it's invoking
because they all report as being set.)
Trying to start a separate instance of Screen
fails with an error message indicating that the resource is busy:

> Cannot open line '/dev/tty.usbserial-FT43TIW00' for R/W: Resource busy

But Screen will start happily
even if the port has been locked with flock/fcntl/lockf.
Screen is clearly relying on some other form of locking,
and just setting whichever of flock/fcntl/lockf it's using
for the benefit of other programs.

No visible UUCP lock file
(`/var/spool/uucp exists`, but is empty).

Let's try strange things.
I've seen `O_EXCL` used when `open(2)`ing ttys.
`open(..., ... | O_EXCL)` fails once Screen has the port open.
But that still can't be what Screen is doing,
because if _I_ open the port with `O_EXCL`,
both Screen and a second instance of my test program will still open it.
The Linux man page for `open(2)`
says that `O_EXCL` without `O_CREAT` will cause `EBUSY` to be returned
when attempting to open an in-use block device,
but neither of the FreeBSD or macOS man pages say anything about that,
or indicate that `EBUSY` is a possible error.
Probably a red herring.

Nuts to this.
Time to pull down the Screen source
and see what it says.
`screen --version` reports

> Screen version 4.00.03 (FAU) 23-Oct-06

And the plist of the newest Screen version
found in Apple's Source Browser
corroborates an upstream version of 4.0.3.
https://opensource.apple.com/source/screen/screen-23/screen.plist.auto.html
Source Browser doesn't let you download archives,
only individual source files;
but modifications noted in the plist
don't suggest they've modified anything I care about,
so I'm just going to work from the upstream source:
https://ftp.gnu.org/gnu/screen/screen-4.0.3.tar.gz

Searching the source for `O_EXCL` turns up one result:
`fileio.c:451`.
(Holy crap, I hate reading GNU-style C formatting.)
What function is this in... `WriteFile`.
That doesn't sound promising.

Squirrel!
Let's go back to trying to figure out the behaviour of the binary
using this `dtrace` thing I've heard so much about:

    sudo dtrace -f open \
                -o screen.dtrace \
                -c 'screen /dev/tty.usbserial-FT43TIW00'

That's, uh.
Yep, `open` gets called a bunch of times.
Fine, let me look up how this thing works.

    sudo dtrace -n 'syscall::open*:entry /execname == "screen"/ { trace(copyinstr(arg0)); trace(arg1); }' \
                -n 'syscall::open*:return /execname == "screen"/ { trace(arg0); }' \
                -o screen.dtrace \
                -c 'screen /dev/tty.usbserial-FT43TIW00'

Cool. Very AWK-like.

Anyway, that output is much more usable:

    CPU     ID                    FUNCTION:NAME
    ...
      2    173                       open:entry   /dev/tty.usbserial-FT43TIW00                131078
      1    174                      open:return                 5

So `oflag` is given as `131078` – `0x20006`.
From reading
`/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/fcntl.h`,
that seems to be `O_RDWR | O_NONBLOCK | O_NOCTTY`.
No sign of `O_EXCL` at all,
as pretty much expected at this point.

Helpfully, if I run and trace a second instance of Screen,
I see that the `open(2)` call returns `-1`.
So it _is_ failing to open the tty device, then:
Screen isn't doing some further locking
after it gets a file descriptor.
Nor is it doing some UUCP-style locking around the device name
prior to opening it.
If I trace `errno` along with the return value,
I see it's 16.
`errno.h` says that's...
yup, `EBUSY`.

Let's go back to the Screen source,
and look for bits of the error message instead.
Nothing for “Resource busy”.
That's the same error message my test program gets from `strerror(3)`, though,
so I'm not surprised.
“Cannot open line” helpfully turns up two very similar-looking results:
one in `tty.sh`, and one in `tty.c.dist`.
Looks like `tty.sh` is a source generator,
whereas `tty.c.dist` is a ready-to-compile capture of its output,
so we'll look at that.

The error message there is in the failure-handling block
for a function called `secopen()`;
seems to be Screen's wrapper around `open(2)`.
Nothing particularly funny.

Oh, but if we scroll down all of 25 lines,
there's an `ioctl` call for `TIOCEXCL`.
According to `tty(4)` (`tty_ioctl(4)` on Linux),

     TIOCEXCL void
                 Set exclusive use on the terminal.  No further opens are per-
                 mitted except by root.  Of course, this means that programs
                 that are run by root (or setuid) will not obey the exclusive
                 setting - which limits the usefulness of this feature.

     TIOCNXCL void
                 Clear exclusive use of the terminal.  Further opens are per-
                 mitted.

There you have it.

## Picocom

Picocom is small enough that I went straight to the source.
Its locking implementation is really straightforward:
based on the compile-time definitions
of `USE_FLOCK` and `UUCP_LOCK_DIR`,
it will try to use `flock(2)` locking,
or its own, hand-rolled implementation of UUCP lock files.
The Makefile as shipped sets `-DUSE_FLOCK`,
which enables the use of `flock(2)`.
The program also accepts an argument
to disable locking at runtime.

It's worth noting that,
although a little disorganized,
Picocom's source tree includes some useful and interesting documentation
of the Linux `termios2` kernel interface,
the behaviour of the RTS line
immediately after opening a serial port on Linux and macOS,
and of custom baud rate behaviour on BSDs.

## Minicom

Minicom (18.8 kloc) is much larger than Picocom (5.9 kloc)
(at least as claimed by the name of the latter!),
but still smaller than Screen (38.1 kloc).
I went straight to the source for Minicom as well.
