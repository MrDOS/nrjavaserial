---
title: How do libraries log?
author: Sam Coleman
---

* TOC
{:toc}

## Introduction

NRJavaSerial is not a new library.
RXTX, from which NRJavaSerial was forked,
dates back to 1998 –
a very different time for Java.
The current Java release at the time was v1.1,
a very different language from modern Java.
One of the many things absent
was logging functionality,
either in the form of first-party functionality in the standard library
or in the canon of popular third-party libraries.
Apache Log4j wasn't released until 2001,
and `java.util.logging` wasn't added until Java 5 was released in 2004.
Applications and libraries alike
were expected to log in the time-honoured tradition
of printing to `stderr`,
and so that's what RXTX did,
from both its Java code, and its JNI C code.
Unfortunately, twenty years later,
and in the face of much change in the language,
its ecosystem, and its idioms,
that's what NRJavaSerial still does.

We obviously [want to change that][slf4j-issue].
If printing to `stdout`/`stderr` is rudimentary for applications,
it's downright rude for libraries.
It reduces the amount of control applications have
over what their users see,
and it makes it hard for developers and systems administrators
to direct and filter logging.

The clear current favourite Java logging API is [SLF4J][slf4j].
It offers bindings to multiple logging frameworks,
meaning that a library which uses it
doesn't force a dependency on any particular logging framework
onto any application which uses that library.

But how do we use it?
I don't mean in the mechanical sense.
That much is easy:
add a dependency to `build.gradle`,
litter the codebase with `static final Logger` instances,
and find/replace calls to `System.(err|out).print(f|ln)?`
with actual log statements.
No, I mean, how much do we log?
What sort of things should we log?
Every second Java programming blog and book
carefully explains the difference between log levels,
but if anyone has ever written any advice specifically for library developers,
I can't find it.

[slf4j-issue]: https://github.com/NeuronRobotics/nrjavaserial/issues/193
[slf4j]: https://www.slf4j.org/

## Methodology

I'm going to try to answer the question myself,
through an empirical survey
of prominent and popular Java libraries.
Specifically, libraries:
I don't want to look
at frameworks,
or at testing tools.
I want things that you run,
rather than things which run you.
Anything which expects to own `public static void main(String[] args)`
is off the table,
as is anything which you wouldn't run in production.

I want to know:

* How much does it log?
  (Logging statements per kLoC,
  with lines of code counted by [SCC][scc]
  and logging statements identified by regex.)
* How much does it log at each log level?
  Does it log anything at `DEBUG`?
  At `TRACE`?
* For libraries which maintain connections to some external resource
  (e.g., database connections):
  * Do they log when opening the connection?
  * When closing it?
  * When operating on it...
    * When the operation is at the explicit behest of the user?
    * When the operation is performed automatically
      (e.g., by a cleanup thread)?
* Who is the intended consumer of log messages:
  library consumers, or library developers?
  Does this vary by log level?

kLoC-based metrics won't be precise,
especially as I'll collect the information via `grep`
instead of AST-based source analysis.
But we're not looking for precision;
just a ballpark idea of typical behaviour.

As for my corpus,
I looked [at “Usages” of the SLF4J API][slf4j-usages]
on Maven Repository.
I grabbed the source archives
for artifacts which weren't part of the SLF4J or Logback implementation,
and which didn't look like a framework or test tool.
I meant to stop after the first ten groups,
but then I didn't.

[scc]: https://github.com/boyter/scc
[slf4j-usages]: https://mvnrepository.com/artifact/org.slf4j/slf4j-api/usages

## Library analysis

### H2 Database Engine

https://mvnrepository.com/artifact/com.h2database/h2/1.4.200

H2 is an relational SQL database engine.
It can be embedded in an application,
similar to the more-well-known SQLite,
or it can operate as a server.
Being a database engine,
H2 is accessed primarily through [the JDBC API][jdbc].
The user won't instantiate connections directly;
instead, they'll call `java.sql.DriverManager.getConnection(String url)`
with a connection URL
indicating the database driver to be used,
and any parameters for that connection
(the name of the database, the database server, credentials, etc.).
H2 offers a set of [per-connection debugging configuration options][h2-trace]
to control where debug messages go.
It offers its own built-in debug logging facility,
which can log to `stdout`, to a file, or delegate to SLF4J.
The former two modes are interesting,
but we're primarily concerned with the SLF4J logging.
It should be the same messages going to all three places, anyway,
with the only variance being the delivery vehicle.

Searching the source for `slf4j` and `LoggerFactory`
turned up results in only one class:
`org.h2.message.TraceWriterAdapter`.
Interesting: all logging in the project
is routed through a single logger instance
with a static name (“h2database”):

```java
private final Logger logger = LoggerFactory.getLogger("h2database");
```

That probably makes it easier
to filter H2-related messages out of the logs,
or to look for them specifically.
It certainly seems to make sense
that a user of an H2 database
won't really care which class
internal to the implementation of the database engine
is producing the message,
only that the message is coming from H2.
The log methods do provide a way
for the caller to name the module on behalf of which it's logging,
but as far as the logging framework is concerned,
all of the messages come from the same place.
One obvious downside
is that logging must require considerably more developer effort.

The peculiarities of this implementation
are probably due to the age of the H2 codebase
and the fact that SLF4J-based logging was tacked onto
the existing logging facilities.
But that's no reason to dismiss the potential benefits.

As its name might imply,
`TraceWriterAdapter` is an implementation of `org.h2.message.TraceWriter`,
which is in turn instantiated and used by `org.h2.message.Trace`.

The regexes I used to scan the codebase for logging calls
were variants on

    \.((error|info|debug)(SQL|Code)?)\(

The codebase consists of 141,590 lines of Java.
Within these, there appear to be
34 error messages,
16 info messages,
and 91 debug messages
(excluding results from within the logging wrapper).
H2's logging facilities
support only these three message levels.

It does seem to log an `INFO`-level messages
both when opening
(`org.h2.engine.Database:634`,
`org.h2.engine.Database:794`)
and closing
(`org.h2.engine.Database:1398`,
`org.h2.engine.Database:1401`,
`org.h2.engine.Database:1458`)
the database.
It also logs `INFO`-level messages
when network clients connect
(`org.h2.engine.Database:1283`)
and disconnect
(`org.h2.engine.Database:1301`,
`org.h2.engine.Database:1316`).
And it logs an `INFO`-level message
for each SQL statement executed
(`org.h2.command.Prepared:335`).

Some other things which pop out at me:

* Long-running queries are noted at `INFO` level
  (`org.h2.command.Command:167`).
* Authentication and permissions failures are noted at `ERROR` level
  (`org.h2.engine.Engine:117`,
  `org.h2.engine.Engine:132`,
  `org.h2.engine.Engine:228`).
  I don't think I like this;
  in my mind,
  an `ERROR` message implies that operator intervention is required;
  but a bad password or a permission violation
  are mundane, common occurrences
  (until there are a lot of them).
  Would I want to know about it?
  Sure, but not any differently from other
  (`INFO`-level)
  logins.
* Exceptions are logged at `ERROR` level,
  except for one which is `DEBUG`;
  but I suspect it's an oversight.
* The only evidence of logging
  from a detached, long-running thread
  is in the file lock watchdog
  (`org.h2.store.FileLock:475-510`).
  It's not particularly interesting;
  `ERROR`-level logging on exceptions,
  a `DEBUG`-level message when waiting for a socket client
  to check in on it,
  and another `DEBUG`-level message before thread termination.
* Notably, neither of the background file writer threads
  (`org.h2.pagestore.WriterThread`,
  `org.h2.mvstore.MVStore.BackgroundWriterThread`)
  nor the network servers
  (`org.h2.server.TcpServerThread`,
  `org.h2.server.pg.PgServerThread`,
  `org.h2.server.web.WebThread`)
  log at all.
  Even exception handlers
  ultimately end up calling something to the effect of
  `java.lang.Throwable.printStackTrace()`.
* All of the log messages at all levels
  seem to be intended to be useful
  to downstream consumers of the library.
  Some of the `DEBUG`-level messages probably aren't useful
  without deeper knowledge of H2 implementation details
  (lots of paging operation details seem to be
  of particularly dubious usefulness),
  but superficially, at least,
  they all seem like they could be useful
  for diagnosing database behaviour
  (performance, contention, locking, whatever).

[jdbc]: https://en.wikipedia.org/wiki/Java_Database_Connectivity
[h2-trace]: http://www.h2database.com/html/features.html#trace_options

### Hibernate (Hibernate Core, Hibernate Validator Engine)

https://mvnrepository.com/artifact/org.hibernate/hibernate-core/5.4.18.Final
https://mvnrepository.com/artifact/org.hibernate/hibernate-validator/6.1.5.Final

Hibernate is a popular [ORM][orm].
It doesn't depend on SLF4J directly;
instead, it uses JBoss Logging,
which, like SLF4J,
is an abstraction layer
which supports multiple different logging implementations
(including Logback, by implementing the SLF4J API).
As Hibernate's documentation [describes][hibernate-logging],
the big selling points of JBoss Logging
are internationalization (translation) support
and numeric message IDs.
This sounds like a pretty powerful combination:
internationalization means the developer or end user
can receive error messages in their preferred language,
while message IDs let you get support for the message
(Google search, etc.)
in a language-agnostic way.

The bindings to JBoss Logging are pretty neat.
In SLF4J, we typically use static methods of `org.slf4j.LoggerFactory`
to retrieve an instance of `org.slf4j.Logger`,
and we log by calling methods on that `Logger` instance.
Hibernate uses JBoss Logging this way, too
(except with `org.jboss.logging.Logger`),
but in some places,
it takes a different approach.
Hibernate Core extends the `org.jboss.logging.BasicLogger` interface
with multiple domain-specific loggers
(primarily `org.hibernate.internal.CoreMessageLogger`,
but also `org.hibernate.bytecode.BytecodeLogger`,
`org.hibernate.cache.spi.SecondLevelCacheLogger`,
`org.hibernate.internal.log.ConnectionAccessLogger`,
`org.hibernate.internal.log.ConnectionPoolingLogger`,
and `org.hibernate.internal.log.DeprecationLogger`),
which declare individual methods
for each distinct log message.
Note that I say Hibernate _extends_ the interface,
not that it _implements_ it:
the implementation is fabricated at runtime
based on the type signature of the logging method
and its annotations.
For example, a log method might be declared like this:

```java
@LogMessage(level = ERROR)
@Message(value = "Expected type: %s, actual value: %s", id = 91)
void expectedType(String name,
                String string);
```

Classes which want to log something
ask the logging framework for a logger instance:

```java
private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, MyClass.class.getName());
```

And then,
instead of dynamically constructing a log message
(e.g., by calling `LOG.debugf(String, Object ...)`),
the business logic calls the logging method
for the specific situation encountered:

```java
LOG.expectedType( expectedType.getName(), value == null ? null : value.getClass().getName() );
```

As expressed by the documentation,
the intent behind log message centralization
seems to be to ease internationalization
and assignment of unique message IDs.
On paper, this sounds like it could be really effective.
However, there are still many ad-hoc log messages.
It's not clear why some messages aren't centralized.
The bulk are `DEBUG`-level messages,
but there are examples of both centralized and ad-hoc log messages
for every logging level used by the project.
Perhaps the ad hoc messages are remnants
of an incomplete migration to centralized logging,
or perhaps the circumstances of their use are archaic and infrequent enough
to not warrant the effort of refactoring.
Regardless, it does feel a bit messy,
and a bit divided.

Because of the vast number of log methods,
even just counting them is no simple feat,
let alone categorizing them by log level.
The saving grace is that all of the static instances
appear to be named either `LOG` or `log`.
Therefore, the (case-insensitive) regex I used
to scan the codebase for logging calls
was

```
\blog\.(?!is\w+Enabled)(\w+)\(
```

To search the codebase,
I used [ripgrep][rg],
along with the conventional `sort` and `uniq`:

```
rg --only-matching \
   --no-filename \
   --ignore-case \
   --pcre2 \
   --replace '$1' \
   '\blog\.(?!is\w+Enabled)(\w+)\(' \
   | sort \
   | uniq -c \
   | sort
```

Incidentally, this shows that the long tail of call frequency
for the various logging methods
is _very_ long.
Out of 288 different logging methods,
237 of them are called from only one place,
and 95% of them are called from three or fewer places.

To build the map from method names to logging levels,
including build-in methods like `debug` and `infof`,
I passed all the source through the following AWK script:

```awk
#! /usr/bin/env -S gawk -f

BEGIN {
    split("debug error fatal info trace warn", levels);
    for (level in levels) {
        methods[levels[level]] = toupper(levels[level])
        methods[levels[level] "f"] = toupper(levels[level])
        methods[levels[level] "v"] = toupper(levels[level])
    }
    level = ""
}

match($0, /@LogMessage\s*\(\s*level\s*=\s*(\w+)\)/, matches) {
    level = matches[1];
}

level != "" && match($0, /void\s+(\w+)\s*\(/, matches) {
    methods[matches[1]] = level;
    level = "";
}

END {
    for (method in methods) {
        print method, methods[method]
    }
}
```

This parses the `@LogMessage` annotations on logging methods
to generate a list of pairs of logging method names
and their corresponding log levels.

To combine the two maps
and get the number of logging points for each log level,
I fed them
(call counts first, then the log level mappings)
into this AWK script:

```awk
#! /usr/bin/env -S gawk -f

FNR == 1 && reading_counts == 1 {
    reading_levels = 1
}

FNR == 1 {
    reading_counts = 1
}

reading_counts && !reading_levels {
    call_counts[$2] = $1
}

reading_levels {
    levels[$2] += call_counts[$1]
}

END {
    for (level in levels) {
        print level, levels[level]
    }
}
```

Hibernate Core is a huge project, with 302,892 lines of Java.
This includes
71 error messages,
168 warning messages,
117 info messages,
817 debug messages,
and 513 trace messages.
JBoss Logging supports fatal-level messages,
but Hibernate Core does not use any.



The Hibernate Validator Engine follows the same approach,
although it only has one log interface
(`org.hibernate.validator.internal.util.logging.Log`).
Over 38,218 lines of Java,
it includes
1 error message,
14 warning messages,
1 info message,
56 debug messages,
and 6 trace messages.
Like Hibernate Core,
it does not use fatal-level messages.

[orm]: https://en.wikipedia.org/wiki/Object-relational_mapping
[hibernate-logging]: https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/logging/Logging.html
[rg]: https://github.com/BurntSushi/ripgrep

### Jetty (Server Core, Servlet Handling)
org.eclipse.jetty/jetty-server
org.eclipse.jetty/jetty-servlet

### Reflections
org.reflections/reflections

### Camel :: Core
org.apache.camel/camel-core

### Apache Commons (Compress, Configuration)
org.apache.commons/commons-compress
org.apache.commons/commons-configuration2

### Apache Hadoop Common
org.apache.hadoop/hadoop-common

### Apache FreeMarker
org.freemarker/freemarker

### Spark Project Core
org.apache.spark/spark-core

### Netty/All In One
io.netty/netty-all

### Quartz
org.quartz-scheduler/quartz

### HikariCP
com.zaxxer/HikariCP

## Conclusion

Numbers of log statements
are given in statements per kLoC.

| Library             | Errors | Warnings | Infos | Debugs | Traces | Total | Open? | Close? | Operation? | Background? |
| ------------------- | -----: | -------: | ----: | -----: | -----: | ----: | :---: | :----: | :--------: | :---------: |
| H2                  |   0.24 |     0.00 |  0.11 |   0.64 |   0.00 |  0.99 |   ✓   |   ✓    |     ✓      |      ✗      |
| Hibernate Core      |   0.23 |     0.55 |  0.39 |   2.70 |   1.69 |  5.57 |   ✓   |   ✓    |     ✓      |      ✗      |
| Hibernate Validator |   0.03 |     0.37 |  0.03 |   1.47 |   0.16 |  2.04 |   ✓   |   ✓    |     ✓      |      ✗      |
