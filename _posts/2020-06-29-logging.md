---
title: How do libraries log?
author: Sam Coleman
---

* TOC
{:toc}

## Introduction

NRJavaSerial is not a new library.
RXTX, from which NRJavaSerial was forked,
dates back to 1998 –
a very different time for Java.
The current Java release at the time was v1.1,
a very different language from modern Java.
One of the many things absent
was logging functionality,
either in the form of first-party functionality in the standard library
or in the canon of popular third-party libraries.
Apache Log4j wasn't released until 2001,
and `java.util.logging` wasn't added until Java 5 was released in 2004.
Applications and libraries alike
were expected to log in the time-honoured tradition
of printing to `stderr`,
and so that's what RXTX did,
from both its Java code, and its JNI C code.
Unfortunately, twenty years later,
and in the face of much change in the language,
its ecosystem, and its idioms,
that's what NRJavaSerial still does.

We obviously [want to change that][slf4j-issue].
If printing to `stdout`/`stderr` is rudimentary for applications,
it's downright rude for libraries.
It reduces the amount of control applications have
over what their users see,
and it makes it hard for developers and systems administrators
to direct and filter logging.

The clear current favourite Java logging API is [SLF4J][slf4j].
It offers bindings to multiple logging frameworks,
meaning that a library which uses it
doesn't force a dependency on any particular logging framework
onto any application which uses that library.

But how do we use it?
I don't mean in the mechanical sense.
That much is easy:
add a dependency to `build.gradle`,
litter the codebase with `static final Logger` instances,
and find/replace calls to `System.(err|out).print(f|ln)?`
with actual log statements.
No, I mean, how much do we log?
What sort of things should we log?
Every second Java programming blog and book
carefully explains the difference between log levels,
but if anyone has ever written any advice specifically for library developers,
I can't find it.

[slf4j-issue]: https://github.com/NeuronRobotics/nrjavaserial/issues/193
[slf4j]: https://www.slf4j.org/

## Methodology

I'm going to try to answer the question myself,
through an empirical survey
of prominent and popular Java libraries.
Specifically, libraries:
I don't want to look
at frameworks,
or at testing tools.
I want things that you run,
rather than things which run you.
Anything which expects to own `public static void main(String[] args)`
is off the table,
as is anything which you wouldn't run in production.

I want to know:

* How much does it log?
  (Logging statements per kLoC,
  with lines of code counted by [SCC][scc]
  and logging statements identified by regex.)
* How much does it log at each log level?
  Does it log anything at `DEBUG`?
  At `TRACE`?
* For libraries which maintain connections to some external resource
  (e.g., database connections):
  * Do they log when opening the connection?
  * When closing it?
  * When operating on it...
    * When the operation is at the explicit behest of the user?
    * When the operation is performed automatically
      (e.g., by a cleanup thread)?
* Who is the intended consumer of log messages:
  library consumers, or library developers?
  Does this vary by log level?

kLoC-based metrics won't be precise,
especially as I'll collect the information via `grep`
instead of AST-based source analysis.
But we're not looking for precision;
just a ballpark idea of typical behaviour.

As for my corpus,
I looked [at “Usages” of the SLF4J API][slf4j-usages]
on Maven Repository.
I grabbed the source archives
for artifacts which weren't part of the SLF4J or Logback implementation,
and which didn't look like a framework or test tool.
I meant to stop after the first ten groups,
but then I didn't.

[scc]: https://github.com/boyter/scc
[slf4j-usages]: https://mvnrepository.com/artifact/org.slf4j/slf4j-api/usages

## Library analysis

### H2 Database Engine

https://mvnrepository.com/artifact/com.h2database/h2/1.4.200

H2 is an relational SQL database engine.
It can be embedded in an application,
similar to the more-well-known SQLite,
or it can operate as a server.
Being a database engine,
H2 is accessed primarily through [the JDBC API][jdbc].
The user won't instantiate connections directly;
instead, they'll call `java.sql.DriverManager.getConnection(String url)`
with a connection URL
indicating the database driver to be used,
and any parameters for that connection
(the name of the database, the database server, credentials, etc.).
H2 offers a set of [per-connection debugging configuration options][h2-trace]
to control where debug messages go.
It offers its own built-in debug logging facility,
which can log to `stdout`, to a file, or delegate to SLF4J.
The former two modes are interesting,
but we're primarily concerned with the SLF4J logging.
It should be the same messages going to all three places, anyway,
with the only variance being the delivery vehicle.

Searching the source for `slf4j` and `LoggerFactory`
turned up results in only one class:
`org.h2.message.TraceWriterAdapter`.
Interesting: all logging in the project
is routed through a single logger instance
with a static name (“h2database”):

```java
private final Logger logger = LoggerFactory.getLogger("h2database");
```

That probably makes it easier
to filter H2-related messages out of the logs,
or to look for them specifically.
It certainly seems to make sense
that a user of an H2 database
won't really care which class
internal to the implementation of the database engine
is producing the message,
only that the message is coming from H2.
The log methods do provide a way
for the caller to name the module on behalf of which it's logging,
but as far as the logging framework is concerned,
all of the messages come from the same place.
One obvious downside
is that logging must require considerably more developer effort.

The peculiarities of this implementation
are probably due to the age of the H2 codebase
and the fact that SLF4J-based logging was tacked onto
the existing logging facilities.
But that's no reason to dismiss the potential benefits.

As its name might imply,
`TraceWriterAdapter` is an implementation of `org.h2.message.TraceWriter`,
which is in turn instantiated and used by `org.h2.message.Trace`.

The regexes I used to scan the codebase for logging calls
were variants on

    \.(error|info|debug)(SQL|Code)?\s*\(

The codebase consists of 210,125 lines of Java.
Within these, there appear to be
34 error messages,
16 info messages,
and 91 debug messages
(excluding results from within the logging wrapper).
H2's logging facilities
support only these three message levels.

It does seem to log an `INFO`-level messages
both when opening
(`org.h2.engine.Database:634`,
`org.h2.engine.Database:794`)
and closing
(`org.h2.engine.Database:1398`,
`org.h2.engine.Database:1401`,
`org.h2.engine.Database:1458`)
the database.
It also logs `INFO`-level messages
when network clients connect
(`org.h2.engine.Database:1283`)
and disconnect
(`org.h2.engine.Database:1301`,
`org.h2.engine.Database:1316`).
And it logs an `INFO`-level message
for each SQL statement executed
(`org.h2.command.Prepared:335`).

Some other things which pop out at me:

* Long-running queries are noted at `INFO` level
  (`org.h2.command.Command:167`).
* Authentication and permissions failures are noted at `ERROR` level
  (`org.h2.engine.Engine:117`,
  `org.h2.engine.Engine:132`,
  `org.h2.engine.Engine:228`).
  I don't think I like this;
  in my mind,
  an `ERROR` message implies that operator intervention is required;
  but a bad password or a permission violation
  are mundane, common occurrences
  (until there are a lot of them).
  Would I want to know about it?
  Sure, but not any differently from other
  (`INFO`-level)
  logins.
* Exceptions are logged at `ERROR` level,
  except for one which is `DEBUG`;
  but I suspect it's an oversight.
* The only evidence of logging
  from a detached, long-running thread
  is in the file lock watchdog
  (`org.h2.store.FileLock:475-510`).
  It's not particularly interesting;
  `ERROR`-level logging on exceptions,
  a `DEBUG`-level message when waiting for a socket client
  to check in on it,
  and another `DEBUG`-level message before thread termination.
* Notably, neither of the background file writer threads
  (`org.h2.pagestore.WriterThread`,
  `org.h2.mvstore.MVStore.BackgroundWriterThread`)
  nor the network servers
  (`org.h2.server.TcpServerThread`,
  `org.h2.server.pg.PgServerThread`,
  `org.h2.server.web.WebThread`)
  log at all.
  Even exception handlers
  ultimately end up calling something to the effect of
  `java.lang.Throwable.printStackTrace()`.
* All of the log messages at all levels
  seem to be intended to be useful
  to downstream consumers of the library.
  Some of the `DEBUG`-level messages probably aren't useful
  without deeper knowledge of H2 implementation details
  (lots of paging operation details seem to be
  of particularly dubious usefulness),
  but superficially, at least,
  they all seem like they could be useful
  for diagnosing database behaviour
  (performance, contention, locking, whatever).

[jdbc]: https://en.wikipedia.org/wiki/Java_Database_Connectivity
[h2-trace]: http://www.h2database.com/html/features.html#trace_options

### Hibernate (Hibernate Core, Hibernate Validator Engine)
org.hibernate/hibernate-core
org.hibernate.validator/hibernate-validator

### Jetty (Server Core, Servlet Handling)
org.eclipse.jetty/jetty-server
org.eclipse.jetty/jetty-servlet

### Reflections
org.reflections/reflections

### Camel :: Core
org.apache.camel/camel-core

### Apache Commons (Compress, Configuration)
org.apache.commons/commons-compress
org.apache.commons/commons-configuration2

### Apache Hadoop Common
org.apache.hadoop/hadoop-common

### Apache FreeMarker
org.freemarker/freemarker

### Spark Project Core
org.apache.spark/spark-core

### Netty/All In One
io.netty/netty-all

### Quartz
org.quartz-scheduler/quartz

### HikariCP
com.zaxxer/HikariCP

## Conclusion

Numbers of log statements
are given in statements per kLoC.

| Library | Errors | Warnings | Infos | Debugs | Traces | Total | Open? | Close? | Operation? | Background? |
| ------- | -----: | -------: | ----: | -----: | -----: | ----: | :---: | :----: | :--------: | :---------: |
| H2      |   0.16 |     0.00 |  0.07 |   0.43 |   0.00 |  0.67 |   ✓   |   ✓    |     ✓      |      ✗      |
